#!/usr/bin/env bash

FOREGROUND=false
NO_SOUND=false
SOUND_FILE=""
VOLUME=""
STOPWATCH=0
POSITIONAL_ARGS=()
STATE_FILE="$HOME/.cache/tymr_state"
DELIMITER="|"
ORIGINAL_ARGS=("$@")
SOUND_LOOP_PGID=""
PLAYER_CMD=""
PLAYER_VOL_FLAG=""
PLAYER_VOL_MULTIPLIER=1
CONFIG_FILE="$HOME/.config/tymr/config"

if [ -f "$CONFIG_FILE" ]; then
  # shellcheck source=/dev/null
  source "$CONFIG_FILE"
fi

if [ -n "$NO_COLOR" ]; then
  C_RED=""
  C_GREEN=""
  C_YELLOW=""
  C_MAGENTA=""
  C_CYAN=""
  C_BOLD=""
  C_DIM=""
  C_RESET=""
else
  C_RED="\e[31m"
  C_GREEN="\e[32m"
  C_YELLOW="\e[33m"
  C_MAGENTA="\e[35m"
  C_CYAN="\e[36m"
  C_BOLD="\e[1m"
  C_DIM="\e[37m"
  C_RESET="\e[0m"
fi

cleanup() {
  [ -n "$SOUND_LOOP_PGID" ] && kill -- -"$SOUND_LOOP_PGID" 2>/dev/null
  # [ -n "$$" ] && delete_timer "$$" false 2>/dev/null
  # dont delete timer so it can be revived later

  # rethrow SIGINT to let parent process also handle it, useful when tymr is in a loop and user do Ctrl+C
  trap - INT
  kill -INT $$
}

trap cleanup INT TERM

err() {
  echo -e "${C_RED}✗ $1${C_RESET}" >&2
}
warn() {
  echo -e "${C_YELLOW}⚠ $1${C_RESET}"
}
success() {
  echo -e "${C_GREEN}✓ $1${C_RESET}"
}
info() {
  echo -e "${C_CYAN}ℹ $1${C_RESET}"
}
dim() {
  echo -e "${C_DIM}$1${C_RESET}"
}

# check dependencies
for cmd in date notify-send; do
  if ! command -v "$cmd" &>/dev/null; then
    err "Command not found: $cmd. Please install it."
    exit 1
  fi
done

opt() {
  local flags="$1"
  local desc="$2"
  printf "  ${C_GREEN}%s${C_RESET}  %s\n" "$flags" "$desc"
}
show_time_format() {
  echo -e "  ${C_BOLD}Plain seconds:${C_RESET}    300, 1500, etc."
  echo -e "  ${C_BOLD}Duration format:${C_RESET}  5m, 2h30m, 1d12h, etc."
  echo -e "  ${C_BOLD}Date/time format:${C_RESET} '10:30', '10:30am', 'next Friday 14:00', '+2 days 5:00pm', etc."
  dim "  See 'date --help' for more information on valid date/time formats."
}
show_help() {
  echo -e "${C_BOLD}USAGE:${C_RESET}"
  echo -e "  timer ${C_DIM}[OPTIONS]${C_RESET} ${C_YELLOW}TIME/DURATION${C_RESET} ${C_DIM}[TIMER_NAME]${C_RESET}"
  echo
  echo -e "${C_BOLD}OPTIONS:${C_RESET}"
  opt "-s, --stopwatch       " "Run as stopwatch (counts up)"
  opt "-f, --foreground      " "Run timer in foreground"
  opt "-n, --no-sound        " "Disable alarm sound"
  opt "-S, --sound-file PATH " "Custom sound file to loop"
  opt "-v, --volume VOL      " "Set volume (1-100)"
  opt "-h, --help            " "Show this help message"
  echo
  echo -e "${C_BOLD}TIMER MANAGEMENT:${C_RESET}"
  opt "-l, --list               " "List active timers"
  opt "-d, --delete PID_OR_NAME " "Delete timer by PID or Timer Name"
  opt "-r, --revive             " "Revive killed timers' processes"
  echo
  echo -e "${C_BOLD}TIME/DURATION FORMATS:${C_RESET}"
  show_time_format
}

detect_player() {
  if [ "$PLAYER_CMD" != "" ]; then
    if command -v "${PLAYER_CMD%% *}" &>/dev/null; then
      return
    else
      warn "Configured audio player '${PLAYER_CMD%% *}' not found. Detecting automatically."
    fi
  fi
  if [ "$NO_SOUND" = true ]; then
    return
  fi
  if command -v paplay &>/dev/null; then
    PLAYER_CMD="paplay"
    PLAYER_VOL_FLAG="--volume="
    PLAYER_VOL_MULTIPLIER=655
  elif command -v ffplay &>/dev/null; then
    PLAYER_CMD="ffplay -nodisp -autoexit -v quiet"
    PLAYER_VOL_FLAG="-volume "
  elif command -v mpv &>/dev/null; then
    PLAYER_CMD="mpv --no-video --no-terminal --no-config"
    PLAYER_VOL_FLAG="--volume="
  else
    warn "No audio player found (paplay, mpv, ffplay). Sound disabled."
    NO_SOUND=true
  fi
}
check_sound_files() {
  if [ -n "$SOUND_FILE" ]; then
    if [ ! -f "$SOUND_FILE" ]; then
      err "Sound file not found: $SOUND_FILE"
      exit 1
    fi
  else
    if [ ! -f /usr/share/sounds/freedesktop/stereo/service-login.oga ] || [ ! -f /usr/share/sounds/freedesktop/stereo/service-logout.oga ]; then
      warn "Default sound files not found. Sound disabled."
      dim "Specify -S / --sound-file with a valid sound file to enable custom sound."
      NO_SOUND=true
    fi
  fi
}

to_seconds() {
  local input="$1"
  local total=0

  while [[ $input =~ ([0-9]+)([smhd]) ]]; do
    local val="${BASH_REMATCH[1]}"
    local unit="${BASH_REMATCH[2]}"

    case $unit in
    s) total=$((total + val)) ;;
    m) total=$((total + val * 60)) ;;
    h) total=$((total + val * 3600)) ;;
    d) total=$((total + val * 86400)) ;;
    esac

    # yeet the matched part from the string, keep parsing
    input="${input#*"${BASH_REMATCH[0]}"}"
  done

  echo "$total"
}

parse_time_input() {
  input="$1"
  if [ -z "$input" ]; then
    err "No time or seconds provided"
    echo >&2
    show_time_format >&2
    return 1
  fi

  if [[ "$input" =~ ^[0-9]+$ ]]; then
    echo "$input"
  elif [[ "$input" =~ ^([0-9]+[dhms])+$ ]]; then
    to_seconds "$input"
  elif target_epoch=$(date -d "$input" +%s 2>/dev/null); then
    current_epoch=$(date +%s)
    if [ "$target_epoch" -le "$current_epoch" ]; then
      err "Specified time is in the past: $input"
      return 1
    fi
    echo $((target_epoch - current_epoch))
  else
    err "Invalid time format: $input"
    echo "Use one of the following formats:" >&2
    show_time_format >&2
    return 1
  fi
}

add_to_state() {
  end_time="$1"
  echo "$$${DELIMITER}${end_time}${DELIMITER}${TIMER_NAME}" >>"$STATE_FILE"
}

delete_timer() {
  local pid_or_name="$1"
  local kill=${2:-true}

  if [ -f "$STATE_FILE" ]; then
    local tmp_file
    tmp_file=$(mktemp)

    local REMOVED_LINE=""

    while IFS= read -r line; do
      IFS="$DELIMITER" read -r pid end_time name <<<"$line"

      if [ "$pid" = "$pid_or_name" ] || [ "$name" = "$pid_or_name" ]; then
        REMOVED_LINE="${C_CYAN}$name${C_RESET} ${C_DIM}(PID: $pid)${C_RESET}"
        [ "$kill" = true ] && kill "$pid" 2>/dev/null
        [ "$kill" = true ] && success "Removed timer: $REMOVED_LINE"
        continue
      fi
      echo "$line" >>"$tmp_file"
    done <"$STATE_FILE"

    mv "$tmp_file" "$STATE_FILE"

    if [ -z "$REMOVED_LINE" ]; then
      err "No matching PID or Name found for '$pid_or_name'"
    fi
  fi
}

list_timers() {
  if [ ! -f "$STATE_FILE" ]; then
    info "No active timers."
    return
  fi

  ALL_ACTIVE=true
  printf "${C_BOLD}%-8s │ %-15s │ %-10s │ %-s${C_RESET}\n" "PID" "End Time" "Time Left" "Name"
  echo "─────────┼─────────────────┼────────────┼────────────────────"

  while IFS= read -r line; do
    IFS="$DELIMITER" read -r pid end_time name <<<"$line"
    current_time=$(date +%s)

    # --- PID Processing ---
    local pid_val="$pid"
    local pid_color="$C_CYAN"
    if ! kill -0 "$pid" 2>/dev/null; then
      ALL_ACTIVE=false
      pid_val="KILLED"
      pid_color="$C_RED"
    fi

    # --- Time Left Processing ---
    local time_left_val
    local time_left_color
    if [ "$end_time" -le "$current_time" ]; then
      time_left_val="EXPIRED"
      time_left_color="$C_RED"
    else
      remaining=$((end_time - current_time))
      local days=$((remaining / 86400))
      local hours=$(((remaining % 86400) / 3600))
      local minutes=$(((remaining % 3600) / 60))

      time_left_val=""
      [ "$days" -gt 0 ] && time_left_val="${days}d "
      [ "$hours" -gt 0 ] && time_left_val="${time_left_val}${hours}h "
      [ "$minutes" -gt 0 ] && time_left_val="${time_left_val}${minutes}m"
      time_left_val="${time_left_val# }"
      time_left_color="$C_GREEN"
    fi

    end_time_str=$(date -d "@$end_time" +"%-d %b %I:%M%P")

    printf "${pid_color}%-8s${C_RESET} │ %-15s │ ${time_left_color}%-10s${C_RESET} │ ${C_MAGENTA}%s${C_RESET}\n" \
      "$pid_val" "$end_time_str" "$time_left_val" "$name"

  done <"$STATE_FILE"

  if [ "$ALL_ACTIVE" = false ]; then
    echo
    err "Some timer processes were KILLED (happens after system restart)"
    warn "Run ${C_BOLD}tymr --revive${C_RESET}${C_YELLOW} to restore them and clean up EXPIRED ones"
    dim "Consider automating that on startup"
  fi

}

revive_timers() {
  if [ ! -f "$STATE_FILE" ]; then
    info "No timers to revive."
    return
  fi

  tmp_file=$(mktemp)

  while IFS= read -r line; do
    IFS="$DELIMITER" read -r pid end_time name <<<"$line"
    current_time=$(date +%s)

    if [ "$end_time" -le "$current_time" ]; then
      warn "Timer expired: ${C_MAGENTA}$name${C_RESET}${C_YELLOW} ${C_DIM}(PID: $pid)${C_RESET}"
      notify-send -u critical "Timer expired while system was off" "Timer: $name, On: $(date -d "@$end_time" '%-d %b %I:%M%P')"
      continue
    fi

    if ! kill -0 "$pid" 2>/dev/null; then
      remaining=$((end_time - current_time))
      success "Reviving: ${C_MAGENTA}$name${C_RESET}${C_GREEN} - ${C_CYAN}$(date -u -d "@$remaining" +%H:%M:%S)${C_RESET}${C_GREEN} remaining${C_RESET}"
      "$0" "$remaining" "$name"
    else
      echo "$line" >>"$tmp_file"
    fi
  done <"$STATE_FILE"

  mv "$tmp_file" "$STATE_FILE"
}

parse_args() {
  while [[ "$#" -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_help
      exit 0
      ;;
    -l | --list)
      list_timers
      exit 0
      ;;
    -r | --revive)
      revive_timers
      exit 0
      ;;
    -d | --delete)
      shift
      if [ -z "$1" ]; then
        err "No PID or Name provided for deletion"
        exit 1
      fi
      delete_timer "$1"
      exit 0
      ;;
    -s | --stopwatch) STOPWATCH=1 ;;
    -f | --foreground) FOREGROUND=true ;;
    -n | --no-sound) NO_SOUND=true ;;
    -S | --sound-file)
      shift
      SOUND_FILE="$1"
      if [ ! -f "$SOUND_FILE" ]; then
        echo "Sound file not found: $SOUND_FILE"
        exit 1
      fi
      ;;
    -v | --volume)
      shift
      VOLUME="$1"
      if ! [[ "$VOLUME" =~ ^[0-9]+$ ]] || [ "$VOLUME" -lt 1 ] || [ "$VOLUME" -gt 100 ]; then
        echo "Volume must be between 1-100"
        exit 1
      fi
      ;;
    -*)
      echo "Unknown option: $1"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1")
      ;;
    esac
    shift
  done

  INPUT_TIME="${POSITIONAL_ARGS[0]}"
  TIMER_NAME="${POSITIONAL_ARGS[1]}"

  if [[ "$TIMER_NAME" == *"$DELIMITER"* ]]; then
    err "Name cannot contain the character: $DELIMITER"
    exit 1
  fi
}

parse_args "$@"

detect_player
check_sound_files

if [ "$FOREGROUND" = false ] && [ $STOPWATCH -eq 0 ]; then
  if ! SECONDS=$(parse_time_input "$INPUT_TIME"); then
    exit 1
  fi
  nohup "$0" --foreground "${ORIGINAL_ARGS[@]}" >/dev/null 2>&1 &
  success "Timer started in background ${C_DIM}(PID: $!)${C_RESET}"
  exit 0
fi

start_stopwatch() {
  end=$(date +%s)
  while true; do
    time=$(($(date +%s) - end))
    printf "${C_CYAN}${C_BOLD}%s${C_RESET}\r" "$(date -u -d "@$time" +%H:%M:%S)"
    sleep 0.5
  done
}

start_timer() {
  end=$(($(date +%s) + $1))
  add_to_state "$end"
  while [ "$end" -ge "$(date +%s)" ]; do
    time="$((end - $(date +%s)))"
    [ "$FOREGROUND" = true ] && printf "${C_GREEN}${C_BOLD}%s${C_RESET}\r" "$(date -u -d "@$time" +%H:%M:%S)"
    sleep 0.5
  done
  delete_timer "$$" false
}

if [ $STOPWATCH -eq 1 ]; then
  start_stopwatch
  exit 0
fi

if ! SECONDS=$(parse_time_input "$INPUT_TIME"); then
  exit 1
fi
start_timer "$SECONDS"
set -m # enable job control. Needed for killing process groups(SOUND_LOOP_PGID)
if [ "$NO_SOUND" = false ]; then
  VOLUME_ARGS=""
  if [ -n "$VOLUME" ]; then
    VOL_VALUE=$((VOLUME * PLAYER_VOL_MULTIPLIER))
    VOLUME_ARGS="$PLAYER_VOL_FLAG$VOL_VALUE"
  fi
  if [ -n "$SOUND_FILE" ]; then
    CMD_TO_RUN="$PLAYER_CMD $VOLUME_ARGS \"$SOUND_FILE\""
    (while :; do
      eval "$CMD_TO_RUN"
    done) &
    SOUND_LOOP_PGID=$!
  else
    CMD_TO_RUN_1="$PLAYER_CMD $VOLUME_ARGS /usr/share/sounds/freedesktop/stereo/service-login.oga"
    CMD_TO_RUN_2="$PLAYER_CMD $VOLUME_ARGS /usr/share/sounds/freedesktop/stereo/service-logout.oga"
    (while :; do
      if command -v timeout &>/dev/null; then
        # --foreground coz it otherwise timeout spawns a new process group, so kill won't work for players
        # this fucking took me 2 hours to debug
        timeout --foreground 2 bash -c "$CMD_TO_RUN_1"
        timeout --foreground 2 bash -c "$CMD_TO_RUN_2"
      else
        bash -c "$CMD_TO_RUN_1"
        bash -c "$CMD_TO_RUN_2"
      fi
    done) &
    SOUND_LOOP_PGID=$!
  fi
fi

notify-send -u critical -w "Time's Up!" "$TIMER_NAME" 2>/dev/null

if [ "$NO_SOUND" = false ] && [ -n "$SOUND_LOOP_PGID" ]; then
  kill -- -"$SOUND_LOOP_PGID" 2>/dev/null
fi
