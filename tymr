#!/usr/bin/env bash

FOREGROUND=false
NO_SOUND=false
SOUND_FILE=""
VOLUME=""
STOPWATCH=0
POSITIONAL_ARGS=()
STATE_FILE="$HOME/.cache/tymr_state"
DELIMITER="|"
ORIGINAL_ARGS=("$@")
SOUND_LOOP_PID=""

cleanup() {
  [ -n "$SOUND_LOOP_PID" ] && kill "$SOUND_LOOP_PID" 2>/dev/null
  [ -n "$$" ] && delete_timer "$$" false 2>/dev/null
  exit
}

trap cleanup INT TERM

err() {
  echo -e "\e[31m$1\e[0m" >&2
}
warn() {
  echo -e "\e[33m$1\e[0m"
}

# check dependencies
for cmd in date notify-send paplay timeout; do
  if ! command -v "$cmd" &>/dev/null; then
    err "Command not found: $cmd. Please install it."
    exit 1
  fi
done

show_time_format() {
  echo "Plain seconds: 300, 1500, etc."
  echo "Duration format: 5m, 2h30m, 1d12h, etc."
  echo "Date/time format: 10:30, 10:30am, 14:45:00, +2 days 5:00pm, etc."
  echo "See 'date --help' for more information on valid date/time formats."
}
show_help() {
  echo "Usage: timer [OPTIONS] TIME_OR_SECONDS [TIMER_NAME]"
  echo
  echo "Options:"
  echo "  -s, --stopwatch        Run as stopwatch (counts up)"
  echo "  -f, --foreground        Run timer in foreground"
  echo "  -n, --no-sound         Disable alarm sound"
  echo "  -S, --sound-file PATH  Custom sound file to loop"
  echo "  -v, --volume VOL       Set volume"
  echo "  -h, --help             Show this help message"
  echo
  echo "  Timers Management:"
  echo "  -l, --list                List active timers"
  echo "  -d, --delete PID_OR_NAME  Delete timer by PID or Timer Name"
  echo "  -r, --revive              Revive killed timers' processes"
  echo
  echo "TIME_OR_SECONDS Formats:"
  show_time_format
}

to_seconds() {
  local input="$1"
  local total=0

  while [[ $input =~ ([0-9]+)([smhd]) ]]; do
    local val="${BASH_REMATCH[1]}"
    local unit="${BASH_REMATCH[2]}"

    case $unit in
    s) total=$((total + val)) ;;
    m) total=$((total + val * 60)) ;;
    h) total=$((total + val * 3600)) ;;
    d) total=$((total + val * 86400)) ;;
    esac

    # yeet the matched part from the string, keep parsing
    input="${input#*"${BASH_REMATCH[0]}"}"
  done

  echo "$total"
}

parse_args() {
  while [[ "$#" -gt 0 ]]; do
    case $1 in
    -h | --help)
      show_help
      exit 0
      ;;
    -l | --list)
      list_timers
      exit 0
      ;;
    -r | --revive)
      revive_timers
      exit 0
      ;;
    -d | --delete)
      shift
      if [ -z "$1" ]; then
        err "No PID or Name provided for deletion"
        exit 1
      fi
      delete_timer "$1"
      exit 0
      ;;
    -s | --stopwatch) STOPWATCH=1 ;;
    -f | --foreground) FOREGROUND=true ;;
    -n | --no-sound) NO_SOUND=true ;;
    -S | --sound-file)
      shift
      SOUND_FILE="$1"
      if [ ! -f "$SOUND_FILE" ]; then
        echo "Sound file not found: $SOUND_FILE"
        exit 1
      fi
      ;;
    -v | --volume)
      shift
      VOLUME="$1"
      if ! [[ "$VOLUME" =~ ^[0-9]+$ ]] || [ "$VOLUME" -lt 1 ] || [ "$VOLUME" -gt 100 ]; then
        echo "Volume must be between 1-100"
        exit 1
      fi
      ;;
    -*)
      echo "Unknown option: $1"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1")
      ;;
    esac
    shift
  done

  INPUT_TIME="${POSITIONAL_ARGS[0]}"
  TIMER_NAME="${POSITIONAL_ARGS[1]}"

  if [[ "$TIMER_NAME" == *"$DELIMITER"* ]]; then
    err "Name cannot contain the character: $DELIMITER"
    exit 1
  fi
}

parse_args "$@"

if [ "$FOREGROUND" = false ]; then
  nohup "$0" --foreground "${ORIGINAL_ARGS[@]}" >/dev/null 2>&1 &
  echo -e "\e[32mStarted timer in background with PID:\e[0m $!"
  exit 0
fi

add_to_state() {
  end_time="$1"
  echo "$$${DELIMITER}${end_time}${DELIMITER}${TIMER_NAME}" >>"$STATE_FILE"
}

delete_timer() {
  local pid_or_name="$1"
  local kill=${2:-true}

  if [ -f "$STATE_FILE" ]; then
    local tmp_file
    tmp_file=$(mktemp)

    local REMOVED_LINE=""

    while IFS= read -r line; do
      IFS="$DELIMITER" read -r pid end_time name <<<"$line"

      # pid mode
      if [ "$pid" = "$pid_or_name" ] || [ "$name" = "$pid_or_name" ]; then
        REMOVED_LINE="PID: $pid, Name: $name"
        [ "$kill" = true ] && kill "$pid" 2>/dev/null
        echo -e "\e[32mRemoved timer:\e[0m $REMOVED_LINE"
        continue
      fi
      echo "$line" >>"$tmp_file"
    done <"$STATE_FILE"

    mv "$tmp_file" "$STATE_FILE"

    if [ -z "$REMOVED_LINE" ]; then
      err "No matching PID or Name found for '$pid_or_name'"
    fi
  fi
}

list_timers() {
  if [ ! -f "$STATE_FILE" ]; then
    echo "No active timers."
    return
  fi

  ALL_ACTIVE=true
  printf "%-8s | %-12s | %-12s | %-s\n" "PID" "End Time" "Time Left" "Name"
  printf '%s\n' "---------------------------------------------------------------"

  while IFS= read -r line; do
    KILLED=false
    IFS="$DELIMITER" read -r pid end_time name <<<"$line"
    current_time=$(date +%s)

    if ! kill -0 "$pid" 2>/dev/null; then
      KILLED=true
      ALL_ACTIVE=false
    fi

    if [ "$end_time" -le "$current_time" ]; then
      time_left_str=$(warn "EXPIRED")
    else
      remaining=$((end_time - current_time))
      time_left_str=$(date -u -d "@$remaining" +%H:%M:%S)
    fi

    # Format end_time as hh:mmam/pm
    end_time_str=$(date -d "@$end_time" +"%I:%M%P")

    [[ "$KILLED" = true ]] && pid="\x1b[31mKILLED\x1b[0m"

    printf "%-8s | %-12s | %-12s | %-s\n" "$pid" "$end_time_str" "$time_left_str" "$name"
  done <"$STATE_FILE"

  if [ "$ALL_ACTIVE" = false ]; then
    err "Some timer's processes were KILLED, happens when you restart your system"
    warn "Run 'tymr --revive' to revive them and kill EXPIRED ones.\nConsider automating this on startup."
  fi

}

revive_timers() {
  if [ ! -f "$STATE_FILE" ]; then
    echo "No timers to revive."
    return
  fi

  tmp_file=$(mktemp)

  while IFS= read -r line; do
    IFS="$DELIMITER" read -r pid end_time name <<<"$line"
    current_time=$(date +%s)

    if [ "$end_time" -le "$current_time" ]; then
      warn "Timer already expired: PID: $pid, Name: $name"
      notify-send -u critical "Timer expired while system was off" "Timer: $name, On: $(date -d "@$end_time" '%-d %b %I:%M%P')"
      continue
    fi

    if ! kill -0 "$pid" 2>/dev/null; then
      remaining=$((end_time - current_time))
      echo -e "\e[32mReviving timer:\e[0m PID: $pid, Name: $name, Remaining: $(date -u -d "@$remaining" +%H:%M:%S)"
      "$0" -b "$remaining" "$name"
    else
      echo "$line" >>"$tmp_file"
    fi
  done <"$STATE_FILE"

  mv "$tmp_file" "$STATE_FILE"
}

start_stopwatch() {
  end=$(date +%s)
  while true; do
    time=$(($(date +%s) - end))
    printf '%s\r' "$(date -u -d "@$time" +%H:%M:%S)"
    sleep 0.5
  done
}

start_timer() {
  end=$(($(date +%s) + $1))
  add_to_state "$end"
  while [ "$end" -ge "$(date +%s)" ]; do
    time="$((end - $(date +%s)))"
    [ "$FOREGROUND" = true ] && printf '%s\r' "$(date -u -d "@$time" +%H:%M:%S)"
    sleep 0.5
  done
  delete_timer "$$" false
}

parse_time_input() {
  input="$1"
  if [ -z "$input" ]; then
    err "No time or seconds provided"
    exit 1
  fi

  if [[ "$input" =~ ^[0-9]+$ ]]; then
    echo "$input"
  elif [[ "$input" =~ ^([0-9]+[dhms])+$ ]]; then
    to_seconds "$input"
  elif target_epoch=$(date -d "$input" +%s 2>/dev/null); then
    current_epoch=$(date +%s)
    if [ "$target_epoch" -le "$current_epoch" ]; then
      err "Specified time is in the past: $input"
      exit 1
    fi
    echo $((target_epoch - current_epoch))
  else
    err "Invalid time format: $input"
    echo "Use one of the following formats:"
    show_time_format
    exit 1
  fi
}

if [ $STOPWATCH -eq 1 ]; then
  start_stopwatch
  exit 0
fi

SECONDS=$(parse_time_input "$INPUT_TIME")
start_timer "$SECONDS"

if [ "$NO_SOUND" = false ]; then
  VOLUME_FLAG=""
  if [ -n "$VOLUME" ]; then
    VOLUME_FLAG="--volume=$((VOLUME * 655))" # volume in paplay is 0-65536
  fi

  if [ -n "$SOUND_FILE" ]; then
    while :; do
      /usr/bin/paplay $VOLUME_FLAG "$SOUND_FILE"
    done &
    SOUND_LOOP_PID=$!
  else
    while :; do
      timeout 2 /usr/bin/paplay $VOLUME_FLAG /usr/share/sounds/freedesktop/stereo/service-login.oga
      timeout 2 /usr/bin/paplay $VOLUME_FLAG /usr/share/sounds/freedesktop/stereo/service-logout.oga
    done &
    SOUND_LOOP_PID=$!
  fi
fi

notify-send -u critical -w "Time's Up!" "$TIMER_NAME"

if [ "$NO_SOUND" = false ] && [ -n "$SOUND_LOOP_PID" ]; then
  kill "$SOUND_LOOP_PID"
fi
